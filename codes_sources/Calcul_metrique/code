import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

# ðŸ”¹ Charger les fichiers CSV
data_reelle = pd.read_csv("/home/fatma/TÃ©lÃ©chargements/gdf.csv", sep='|')  
df_model1 = pd.read_csv("/home/fatma/TÃ©lÃ©chargements/all_regions_predictions_timegpt_fibre.csv")  
df_model2 = pd.read_csv("/home/fatma/TÃ©lÃ©chargements/timesfm_all_regions_predictions_fibre.csv")  
df_model3 = pd.read_csv("/home/fatma/TÃ©lÃ©chargements/Moirai_all_regions_predictions._fibre.csv")  

# ðŸ”¹ Renommer les colonnes selon les modÃ¨les
df_model1 = df_model1.rename(columns={'y': 'model1_pred'})  # TimeGPT
df_model2 = df_model2.rename(columns={'y': 'model2_pred'})  # TimesFM
df_model3 = df_model3.rename(columns={'y': 'model3_pred'})  # Moirai

# ðŸ”¹ Convertir les dates
data_reelle['ds'] = pd.to_datetime(data_reelle['ds'])
df_model1['ds'] = pd.to_datetime(df_model1['ds'])
df_model2['ds'] = pd.to_datetime(df_model2['ds'])
df_model3['ds'] = pd.to_datetime(df_model3['ds'])

# ðŸ”¹ SÃ©curitÃ© sur les types
data_reelle['y'] = data_reelle['y'].astype(float)

# ðŸ”¹ Fusion des donnÃ©es
df = data_reelle.copy()
df = df.merge(df_model1[['ds', 'region', 'model1_pred']], on=['ds', 'region'], how='left')
df = df.merge(df_model2[['ds', 'region', 'model2_pred']], on=['ds', 'region'], how='left')
df = df.merge(df_model3[['ds', 'region', 'model3_pred']], on=['ds', 'region'], how='left')

# ðŸ”¹ DÃ©codage des noms de rÃ©gions (correction encodage UTF-8)
df['region'] = df['region'].apply(lambda x: x.encode('latin1').decode('utf-8') if isinstance(x, str) else x)

# ðŸ”¹ Conversion numÃ©rique
df[['model1_pred', 'model2_pred', 'model3_pred']] = df[['model1_pred', 'model2_pred', 'model3_pred']].apply(pd.to_numeric, errors='coerce')

# ðŸ”¹ Fonction d'Ã©valuation
def evaluate_model(y_true, y_pred):
    y_pred = y_pred.fillna(0)  # Remplacer les NaN
    mae = mean_absolute_error(y_true, y_pred)
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    mape = np.mean(np.abs((y_true - y_pred) / y_true.replace(0, np.nan))) * 100  # Ã©viter div/0
    r2 = r2_score(y_true, y_pred)
    return {'MAE': mae, 'RMSE': rmse, 'MAPE': mape, 'R2': r2}

# ðŸ”¹ Analyse des performances globales (non pas par rÃ©gion)
y_true = df['y']
all_results = []

# Calcul des mÃ©triques pour chaque modÃ¨le
models = ['model1_pred', 'model2_pred', 'model3_pred']

for model in models:
    if model in df.columns:
        metrics = evaluate_model(y_true, df[model])
        metrics.update({'model': model})
        all_results.append(metrics)

# ðŸ”¹ RÃ©sumÃ© des rÃ©sultats globaux
results_df = pd.DataFrame(all_results)
results_df = results_df[['model', 'MAE', 'RMSE', 'MAPE', 'R2']]
print("\nðŸ“Š RÃ©sultats globaux :\n", results_df)

# ðŸ”¹ Export des rÃ©sultats
results_df.to_csv("/home/fatma/TÃ©lÃ©chargements/resultats_globaux.csv", index=False)

# ðŸ”¹ Analyse statistique des prÃ©dictions
print("\nðŸ“ˆ Statistiques des prÃ©dictions :\n", df[['model1_pred', 'model2_pred', 'model3_pred']].describe())

# ðŸ”¹ TracÃ© des erreurs des modÃ¨les
plt.figure(figsize=(12, 6))
for model in models:
    plt.plot(df['ds'], abs(df['y'] - df[model]), label=f"Erreur {model}", linestyle='--')

plt.legend()
plt.title("Ã‰volution des erreurs de prÃ©diction par modÃ¨le")
plt.xlabel("Date")
plt.ylabel("Erreur absolue")
plt.grid()
plt.show()
