!pip install git+https://github.com/amazon-science/chronos-forecasting.git
!pip install timesfm
import pandas as pd
import numpy as np
import timesfm
import matplotlib.pyplot as plt
import torch
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error

# âœ… VÃ©rifier si un GPU est disponible
use_gpu = torch.cuda.is_available()
backend = "gpu" if use_gpu else "cpu"

# âœ… Initialiser TimesFM avec les bons paramÃ¨tres
model = timesfm.TimesFm(
    hparams=timesfm.TimesFmHparams(
        backend=backend,
        per_core_batch_size=32,
        horizon_len=128,
        context_len=2048,
        num_layers=50,
        use_positional_embedding=False,
    ),
    checkpoint=timesfm.TimesFmCheckpoint(
        huggingface_repo_id="google/timesfm-2.0-500m-pytorch"
    ),
)

print(f"âœ… TimesFM chargÃ© avec PyTorch sur {backend.upper()}.")

# âœ… Charger les donnÃ©es
df = pd.read_csv("/content/df_counts_preprocessing.csv")

# âœ… CrÃ©er la colonne 'ds' en combinant 'jour' et 'heure'
df['ds'] = pd.to_datetime(df['jour'].astype(str) + ' ' + df['heure'].astype(str), errors="coerce")

# âœ… Ajouter des colonnes pour le jour de la semaine, mois et jour de l'annÃ©e
df['jour_semaine'] = df['ds'].dt.dayofweek
df['mois'] = df['ds'].dt.month
df['jour_de_l_annee'] = df['ds'].dt.dayofyear

# âœ… CrÃ©ation d'un DataFrame avec les colonnes cibles comme 'y'
df_expanded = df[['ds', 'count_fixe_jdid', 'count_4g', 'count_5g_box', 'count_fibre', 'jour_semaine', 'mois', 'jour_de_l_annee']]

# âœ… Convertir 'ds' en index pour une utilisation dans TimesFM
df_expanded.set_index('ds', inplace=True)

# âœ… Liste des colonnes cibles
target_columns = ['count_fixe_jdid', 'count_4g', 'count_5g_box', 'count_fibre']

# âœ… Liste pour stocker les prÃ©visions
future_data = []

plt.figure(figsize=(12, 6))

# âœ… PrÃ©dictions pour chaque technologie (on limite Ã  5 pour Ã©viter trop de courbes)
for target in target_columns:
    # ðŸŽ¯ Filtrer les donnÃ©es pour la colonne cible actuelle
    target_data = df_expanded[['jour_semaine', 'mois', 'jour_de_l_annee', target]].dropna()

    # ðŸ“Œ VÃ©rifier si les donnÃ©es sont suffisantes
    if len(target_data) < 10:
        print(f"âš ï¸ Pas assez de donnÃ©es pour {target}, prÃ©vision ignorÃ©e.")
        continue

    # ðŸŽ¯ Appliquer TimeFM
    forecast_horizon = 300  # 30 heures de prÃ©vision
    forecast_input = [target_data[target].values]  # Convert 'count' column to numpy array
    frequency_input = [0]  # Assume a single time series with frequency 0

    point_forecast, _ = model.forecast(forecast_input, freq=frequency_input)

    # ðŸ”„ Ajuster la longueur de la colonne 'time' pour correspondre Ã  la prÃ©vision
    forecast_dates = pd.date_range(start=target_data.index.max(), periods=len(point_forecast[0]), freq='H')

    # CrÃ©er un DataFrame pour les prÃ©visions
    forecast = pd.DataFrame({'time': forecast_dates,
                             'forecast': point_forecast[0]})

    # ðŸ”„ Convert 'time' column to matplotlib-compatible format
    forecast['time'] = pd.to_datetime(forecast['time']).astype('int64') // 10**9  # Convert to numeric

    # ðŸ“Š Affichage des courbes
    plt.plot(pd.to_datetime(target_data.index).astype('int64') // 10**9, target_data[target], label=f'DonnÃ©es rÃ©elles ({target})')
    plt.plot(forecast['time'], forecast['forecast'], label=f'PrÃ©visions ({target})', linestyle='dashed')

    # ðŸ“‚ Sauvegarder les prÃ©visions
    forecast.to_csv(f"prediction_30heures_{target}.csv", index=False)
    print(f"ðŸ“ PrÃ©visions pour {target} enregistrÃ©es dans 'prediction_300heures_{target}.csv'")

    # ðŸ” Calcul des mÃ©triques
    y_true = target_data[target].values[-len(forecast):]  # DerniÃ¨res valeurs rÃ©elles disponibles pour la comparaison
    y_pred = forecast['forecast'].values

    # RÂ²
    r2 = r2_score(y_true, y_pred)

    # MAE (Mean Absolute Error)
    mae = mean_absolute_error(y_true, y_pred)
    print(f"ðŸ“Š MAE pour {target}: {mae:.4f}")

    # MSE (Mean Squared Error)
    mse = mean_squared_error(y_true, y_pred)
    print(f"ðŸ“Š MSE pour {target}: {mse:.4f}")

# ðŸŽ¨ Mise en forme du graphique
plt.xlabel('Date et Heure')
plt.ylabel('Occurrences')
plt.title('PrÃ©dictions des diffÃ©rentes technologies sur 300 heures')
plt.legend()
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()
